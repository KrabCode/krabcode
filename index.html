<meta charset="UTF-8">
<!doctype html>
<html>
<head>
    <link rel="stylesheet" type="text/css" href="styles.css">
    <title>krabcode</title>


    <script type="text/javascript">// <![CDATA[

      var gl;
      var canvas;
      var buffer;

      var shaderScript;
      var shaderSource;
      var vertexShader;
      var fragmentShader;

      var timeLocation;
      var timeStamp = 0;
      var resolutionLocation;

      window.onload = init;

      function init() {
    	canvas        = document.getElementById('webgl-canvas');
    	gl            = canvas.getContext('experimental-webgl');

    	canvas.width  = 640;
    	canvas.height = 480;

    	gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([
          -1.0, -1.0,
           1.0, -1.0,
          -1.0,  1.0,
          -1.0,  1.0,
           1.0, -1.0,
           1.0,  1.0]),
        gl.STATIC_DRAW
      );

      shaderScript = document.getElementById("2d-vertex-shader");
      shaderSource = shaderScript.text;
      vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, shaderSource);
      gl.compileShader(vertexShader);

      shaderScript   = document.getElementById("2d-fragment-shader");
      shaderSource   = shaderScript.text;
      fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, shaderSource);
      gl.compileShader(fragmentShader);

      program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      gl.useProgram(program);

      timeLocation = gl.getUniformLocation(program, "time");
      resolutionLocation = gl.getUniformLocation(program, "resolution");
    	render();

      }

      function render() {
        window.requestAnimationFrame(render, canvas);
        gl.clearColor(1.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        positionLocation = gl.getAttribLocation(program, "a_position");
        gl.uniform1f(timeLocation, timeStamp/60.0);
        timeStamp += 1;
        gl.uniform2f(resolutionLocation, canvas.width,canvas.height);
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }

    // ]]>
    </script>

    <script id="2d-vertex-shader" type="x-shader/x-vertex">// <![CDATA[
    attribute vec2 a_position;
      void main() {
        gl_Position = vec4(a_position, 0, 1);
      }

    // ]]>
    </script>

    <script id="2d-fragment-shader" type="x-shader/x-fragment">// <![CDATA[
      precision highp float;
      uniform float time;
      uniform vec2 resolution;

      #define pi 3.14159265359
      #define S(a, b, t) smoothstep(a, b, t)

      vec3 random3(vec3 c) {
          float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
          vec3 r;
          r.z = fract(512.0*j);
          j *= .125;
          r.x = fract(512.0*j);
          j *= .125;
          r.y = fract(512.0*j);
          return r-0.5;
      }

      const float F3 =  0.3333333;
      const float G3 =  0.1666667;
      float snoise(float x0,float y0, float z0) {
          vec3 p = vec3(x0,y0,z0);
          vec3 s = floor(p + dot(p, vec3(F3)));
          vec3 x = p - s + dot(s, vec3(G3));
          vec3 e = step(vec3(0.0), x - x.yzx);
          vec3 i1 = e*(1.0 - e.zxy);
          vec3 i2 = 1.0 - e.zxy*(1.0 - e);
          vec3 x1 = x - i1 + G3;
          vec3 x2 = x - i2 + 2.0*G3;
          vec3 x3 = x - 1.0 + 3.0*G3;
          vec4 w, d;
          w.x = dot(x, x);
          w.y = dot(x1, x1);
          w.z = dot(x2, x2);
          w.w = dot(x3, x3);
          w = max(0.6 - w, 0.0);
          d.x = dot(random3(s), x);
          d.y = dot(random3(s + i1), x1);
          d.z = dot(random3(s + i2), x2);
          d.w = dot(random3(s + 1.0), x3);
          w *= w;
          w *= w;
          d *= w;
          return dot(d, vec4(52.0));
      }

      float cubicPulse( float c, float w, float x ){
      	 x = abs(x - c);
      	 if( x>w ) return 0.0;
      	 x /= w;
      	 return 1.0 - x*x*(3.0-2.0*x);
      }

      vec3 rgb( in vec3 c ){
       vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0 );
       rgb = rgb*rgb*(3.0-2.0*rgb);  return c.z * mix(vec3(1.0), rgb, c.y);
      }

      mat2 rotate2d(float angle){
      	return mat2(cos(angle),-sin(angle), sin(angle),cos(angle));
      }

      float distLine(vec2 p, vec2 a , vec2 b){
        vec2 pa = p-a;
        vec2 ba = b-a;
        float t = clamp(dot(pa,ba)/dot(ba,ba), .0, 1.);
        return length(pa-ba*t);
      }

      float line(vec2 p, vec2 a, vec2 b){
        float d = distLine(p,a,b);
        float m = S(.005, .00, d);
        float dd = length(a-b);
        m *= (S(1.2,.0,dd)) + S(.03, 0.0, abs(.5-dd)) ;
        return m;
      }

      float N21(vec2 p){
        p = fract(p*vec2(230.44,80.73));
        p += dot(p,p+19.5);
        return fract(p.x*p.y);
      }

      vec2 N22(vec2 p){
        float n = N21(p);
        return vec2(n, N21(p+n));
      }

      vec2 getPos(vec2 id, vec2 offset){
        vec2 n = N22(id+offset)*(800.+time*.5);
        return offset+sin(n)*.45;
      }

      float drawGrid(vec2 uv){
        vec2 gv = fract(uv)-.5;
        vec2 id = floor(uv);
        vec2 pos  = getPos(id,vec2(0.));
        float resultColor = 0.;

        //draw line from center to all direct  neighbours
        for(float x = -1.; x <= 1.; x++){
          for(float y = -1.; y <= 1.; y++){
            vec2 offpos = getPos(id,vec2(x,y));
            resultColor += line(gv, pos, offpos);
            float lightIntensity = 40.;
            vec2 j = (offpos-gv)*lightIntensity;
            float light = 1./dot(j,j);
            resultColor += light;
          }
        }

        //draw  lines crossing the center but not originating in it
        resultColor += line(gv,getPos(id, vec2(-1., 0.)), getPos(id, vec2(0., -1.)));
        resultColor += line(gv,getPos(id, vec2(-1., 0.)), getPos(id, vec2(0.,  1.)));
        resultColor += line(gv,getPos(id, vec2( 1., 0.)), getPos(id, vec2(0., -1.)));
        resultColor += line(gv,getPos(id, vec2( 1., 0.)), getPos(id, vec2(0.,  1.)));
        return resultColor;
      }


      void main(){
        vec2 uv = (gl_FragCoord.xy-.5*resolution.xy)/resolution.y;
        vec3 hsb = vec3(0.,0.,0.);
        float len = .5;
        float dist = length(uv);
        vec2 a = vec2(-len,0.);
        vec2 b = vec2(len,0.);
        vec2 c = vec2(-len,0.);
        vec2 d = vec2(len,0.);

        float off = .03*sin(15.*uv.x+time);
         off += .003*sin(150.*uv.x-time*10.);
        a.y += off;
        b.y += off;
        c.y -= off;
        d.y -= off;

        const float scl = .025;
        uv.x = mod(uv.x, scl);
        hsb.b += line(uv,vec2(scl*.5,off), vec2(scl*.5, -off));

        gl_FragColor = vec4(rgb(hsb),1.);
      }
    // ]]>
    </script>


</head>

   <body>
       <canvas id="webgl-canvas"></canvas>
   </body>
</html>
